====================================================================
Author: Gautham Ganesh
Description:
    Uses a TensorFlow Lite model for efficient inference
    on Raspberry Pi or desktop.

    ‚úÖ Select Reference & Test images
    ‚úÖ Displays both side-by-side
    ‚úÖ Predicts Genuine / Forged with confidence
====================================================================
"""

import os
import cv2
import numpy as np
import tensorflow as tf
import tkinter as tk
from tkinter import filedialog
from PIL import Image, ImageTk

# ======================================================
# ‚öôÔ∏è Configuration
# ======================================================
TFLITE_MODEL_PATH = r"/home/pi/Signature_Verification_System/signature_verification_contrastive_fp16.tflite"
IMG_SIZE = (128, 128)
THRESHOLD = 0.91  # From evaluation best F1 threshold

# ======================================================
# üß† Load TFLite Model
# ======================================================
print("üîÅ Loading TFLite model...")
interpreter = tf.lite.Interpreter(model_path=TFLITE_MODEL_PATH)
interpreter.allocate_tensors()
print("‚úÖ TFLite model loaded successfully.")

# Get input/output details
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()
print(f"üì• Inputs: {len(input_details)} | üì§ Outputs: {len(output_details)}")

# ======================================================
# üßº Preprocessing
# ======================================================
def preprocess_image(image_path):
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"Cannot read {image_path}")
    img = cv2.re===================================
# üßÆ Prediction Logic (TFLite)
# ======================================================
def predict_similarity(img_path1, img_path2):
    img1 = preprocess_image(img_path1)
    img2 = preprocess_image(img_path2)

    # Depending on model structure, there may be 1 or 2 inputs.
    if len(input_details) == 2:
        interpreter.set_tensor(input_details[0]['index'], img1)
        interpreter.set_tensor(input_details[1]['index'], img2)
    else:
        # Some siamese models combine both inputs, adapt if needed.
        combined = [img1, img2]
        interpreter.set_tensor(input_details[0]['index'], np.array(combined))

    interpreter.invoke()

    # Get the output
    distance = interpreter.get_tensor(output_details[0]['index'])[0][0]
    similarity = 1 - distance
    label = "Genuine ‚úÖ" if similarity >= THRESHOLD else "Forged ‚ùå"
    return label, similarity, distance

# ======================================================
# üé® GUI Setup
# ======================================================
root = tk.Tk()
root.title("Signature Verification System (TFLite)")
root.geometry("800x600")
root.configure(bg="#101820")

font_title = ("Arial", 20, "bold")
font_label = ("Arial", 14)
font_result = ("Arial", 18, "bold")

reference_path = None
test_path = None

# ======================================================
# üñºÔ∏è Image Display Function
# ======================================================
def show_image(img_path, label_widget):
    img = Image.open(img_path)
    img = img.resize((300, 150))
    img = ImageTk.PhotoImage(img)
    label_widget.configure(image=img)
    label_widget.image = img

# ======================================================
# üìÇ Browse Functions
# ======================================================
def browse_reference():
    global reference_path
    reference_path = filedialog.askopenfilename(
        title="Select Reference Signature", filetypes=[("Image Files", "*.png;*.jpg;*.jpeg")]
    )
    if reference_path:
        show_image(reference_path, label_ref)
        ref_label_text.set(f"Reference Loaded: {os.path.basename(reference_path)}")

def browse_test():
    global test_path
    test_path = filedialog.askopenfilename(
        title="Select Test Signature", filetypes=[("Image Files", "*.png;*.jpg;*.jpeg")]
    )
    if test_path:
        show_image(test_path, label_test)
        test_label_text.set(f"Test Loaded: {os.path.basename(test_path)}")

# ======================================================
# üîç Verify Action
# ======================================================
def verify_signatures():
    if not reference_path or not test_path:
        result_text.set("‚ö†Ô∏è Please select both images first!")
        return

    try:
        label, similarity, distance = predict_similarity(reference_path, test_path)
